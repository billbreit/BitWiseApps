"""Demo of IOMapper

module:     fan_example
version:    v0.0.1
sourcecode: https://github.com/billbreit/BitWiseApps
copyleft:   2025 by Bill Breitmayer
licence:    GNU GPL v3 or above
author:     Bill Breitmayer

The Fan Mapper is an extended example of IOMapper, driving a process
as defined by IOMap and IOMapper parameters.  The map is from action
keywords to objects methods or APIs of imaginary devices, programs or protocols.
The IOMap and conditions defined in the driver code simulates the a simple
( and inexpensive ! ) fan with some non-simple logic requirements,
plus a few major design problems.

There are three key factors: the room temperature, the fan state ( on/off )
and the fan internal temperature, which is basically the average room temp plus
the internal heat generated by the running fan.

The fan motor burns out at 42C.  The trick is to keep the fan running while
avoidong overheating the fan motor and burning it out.

A DEAD FAN Exception happens about one in ten runs.  In some cases on some
machines ( particularly mc-ers ), the exceptions seem to cluster, happening
about two or three times in sucession and the not at all for a dozen or
so runs.  Really random ???  Apparently not.

Same function as fan_engine, but with trigger/action expressed with 'leveled'
if:else: structures.  Smaller, faster than IOEngine.

"""

try:
    from gc import mem_free, mem_alloc, collect
    mem_free_avail = True
    collect()  # seems to make a difference. why ?
    start_mem = mem_free()
    start_memalloc = mem_alloc()
except ImportError:
    mem_free_avail = False

from lib.vdict import checkstats

from iomapper import SetVal, Run

from fan_mapper import CheapFanIOMapper


if __name__ == '__main__':

    if mem_free_avail:
        start_main_mem = mem_free()

    DEBUG = True
    # iomapper.MDEBUG = True   # uncomment here and import for MDEBUG

    print()
    print('### Fan IOMapper Prototype ###')
    print()

    iom = CheapFanIOMapper()  # use default _values dict
    print()
    print('### Starting IOMapper Run ###')
    print()

    def run_cycle():
        """ Equivalent conditions

        conditions = { 'fan_suspend':
                     [Condition('fan_overheated', 'eq', True ),
                     Condition('fan_state', 'eq', 'fan_ON' )],

                'fan_unsuspend':
                    [Condition('fan_overheated', 'eq', False ),
                    Condition('fan_state', 'eq', 'fan_SUSPEND' )],

                'fan_on' : [
                    [Condition('fan_overheated', 'eq', False ),
                     Condition('fan_state', 'eq', 'fan_OFF' ),
                     Condition('room_temp', 'gt', 'upper_limit')],

                    [Condition('fan_overheated', 'eq', False ),  # OR
                     Condition('fan_state', 'eq', 'fan_OFF' ),
                     Condition('switch_state', 'eq', 'switch_ON')]],

                'fan_off':
                    [Condition('fan_overheated', 'eq', False ),
                     Condition('fan_state', 'eq', 'fan_ON' ),
                     Condition('switch_state', 'eq', 'switch_OFF'),
                     Condition('room_temp', 'lt', 'lower_limit')]
              }
        """

        iom.read_into_values()  # using iom defined read_keys.

        print('Updated value dict: ', iom.values)
        print()
        actions = []

        if DEBUG: print('Keys changed:  ', iom.values.keys_changed(), '\n')

        # Implementation of Fan Mapper logic, state transitions

        vd = iom.values  # values dict

        if vd['fan_overheated'] == True:
            if vd['fan_state'] == vd['fan_ON']:
                iom.add_agenda(Run('fan_suspend'))

        else:   # normal operation

            if vd['fan_state'] == vd['fan_SUSPEND']:

                iom.add_agenda(Run('fan_unsuspend'))

            elif vd['fan_state'] == vd['fan_OFF']:
                if (vd['room_temp'] > vd['upper_limit'] or
                    vd['switch_state'] == vd['switch_ON']):

                    iom.add_agenda(Run('fan_on'))

            elif vd['fan_state'] == vd['fan_ON']:
                if vd['switch_state'] == vd['switch_OFF']:
                    if vd['room_temp'] < vd['lower_limit']:
                        iom.add_agenda(Run('fan_off'))
            else:
                pass # debugging, no action

    def erun(iom, limit:int):

        n = 1

        print('... using fan object: ', iom.values['fan'])
        print()

        fanref = iom.values['fan']

        while n <= limit:

            print('Running cycle: ', n)
            print()

            run_cycle()
            
            if n==4:
                print('-> Setting switch_on')
                iom.add_agenda(Run('switch_on'))
                print()

            if n==8:
                print('-> Setting switch_off')
                iom.add_agenda(Run('switch_off'))
                print('-> Setting thermostat to 34 ')
                iom.add_agenda(SetVal('thermstat_setting', 34.0))
                iom.add_agenda(Run('thermstat_reset'))
                print()

            print('room temp:         ', iom.values['room_temp'])
            print('fan state:         ', ['off', 'on', 'suspended'][fanref.state])
            print('fan history:       ', fanref.state_history)
            print('fan internal_temp: ', round(fanref.internal_temp, 2))
            print('switch state:      ', ['off', 'on'][iom.values['switch_state']])
            print('keys changed:      ', iom.values.keys_changed())
            print('agenda:           ', iom.agenda)             
            print()

            n += 1

    erun(iom, 16)

    print()
    print('### End run ')
    print('Values dict ->')

    checkstats(iom.values)

    # print(locals())

    if mem_free_avail:
        print('Memory Usage')
        print('Start mem free:           ', start_mem )
        print('Start mem alloc:          ', start_memalloc )
        print('Free/Usage start __main__:', start_main_mem, '/', start_mem - start_main_mem)
        print('Free/Usage end __main__ : ', mem_free(), '/', start_mem - mem_free())
        collect()
        print('Free/Usage (collected):   ', mem_free(), '/', start_mem - mem_free())
        print('Mem Alloc:                ', mem_alloc(), ' ')

""""
Arduino ESP32
Memory Usage ( 1.22 )
Start mem free:            8196496
Start mem alloc:           57968
Free/Usage start __main__: 8192544 / 3952
Free/Usage end __main__ :  8133488 / 63008 (diff ?)
Free/Usage (collected):    8199872 / -3376
Mem Alloc:                 54592

RP2040  ( 1.23 )
Memory Usage
Start mem free:            117312
Start mem alloc:           74112
Free/Usage start __main__: 113360 / 3952
Free/Usage end __main__ :  102480 / 14832
Free/Usage (collected):    120784 / -3472
Mem Alloc:                 70640

Note: number above after a few runs.  Mem alloc may be more reliable/stable
overall, but will total_mem - mem_alloc always = free mem ?  Doesn't look
like it, so numbers ( and definitions ? ) are approximate.

"""





